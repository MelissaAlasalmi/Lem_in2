s-r1  // 0
s-r2  // 1
r2-r3 // 2
r1-r3 // 3
r1-r4 // 4
r3-r5 // 5
r4-r3 // 6
r5-e // 7
e-r4 // 8

inteded:

s
|
r1 --- r2
|
r3

	s-r1-r4-end
	s-r1-r3-r4-end
	s-r2-r3-r4-end
  s-r2-r3-r5-end

	* r1-r4
	//r1-r3-r4
  //r2-r3-r4
	* r2-r3-r5


                    ---- s(0) ----
                  /                \
                r1(1) ------------ r2(2)
                  |                  |
        r4(9)--------r3(8)          r3(3)
          |            |             |
          e(10)        r5(11)        r5(4) ---- r4(5)
                        |             |           |
                        e(12)        e(7)         e(6)

	S	   
   |  \    
   r2  r1		
    \    | \
      - r3 - r4	  
	   	|		\   |
		r5 ---  end 

s-r2-r3-r4-e
s-r2-r3-r5-e
s-r2-r3-r5-r4-e
s-r2-r3-r5-r4-e
s-r1-r3-r4-e
s-r1-r3-r5-e
s-r1-r4-e
s-r1-r4-r3-r5-e







0-4 
0-6
1-3 
4-3 
5-2
3-5 
4-2 
2-1 
7-6 
7-2 
7-4 //
6-5

              ____________
            /              \
      ____[5]------[3]--[1] |
     /              |    /  |
   [6]------[0]----[4]  /   |
    \    _________/ |  /    |
     \ /           [2]/____/
     [7]___________/



1
|
3---------2
|		  |
4---5     9
|	|	  |
8	9--6  5----4----7
	|  |  |	   |    |
	7  8  6    8    6
	  	  |	        |
          8         8



1
|
3(1)---------------2
|                  |
4(2)---5           5(3)-----4-----7
|      |             |      |     |
8(9)  6(10)         6(4)    8(5)  6(6)
        |             |           |
        8(11)        8(8)         8(7)
       



// Need to have a condition where if only one ant, send it thru the best path right away.
// If more than one ant, prefer multi-paths even if one or two step longer.


        
         [s] 
      /   |
  [r1]   [r2]---[r3]
    |     |      |
  [r4]---[r5]   [r6]
          |   /
         [e]

              Path 1             Path 2             Path 3       
            s-r2-r5-e         s-r1-r4-r5-e      s-r2-r3-r6-e
Length          2                   3                 3
ANTS           Single                     Both
1               3                          
2               4                          4
3               5                          5
4               6                          5

if (ants < 4)
    use path 1

Int path 1 s-r2-r5-e

int path 2
int path 3


ANTS   STEPS MIDDLE | ALL

1              1
2              2        2
3              3        2
4              


s r3  r2 r4 r1 e
1  2  3  4   5 9

int arr = 0[ 1, 2, 8, 9]
          1[ 1, 6, 2, 9]
          2[ 1, 5, 4, 2, 9]

          3[ 1, 5, 9]
          4[ 1, 4, 2, 9]


0:-4|1|3|4|8|-1
1:-5|1|2|5|6|8|-1
2:-4|1|2|4|8|-1
3:-5|1|2|7|6|8|-1
4:-5|1|3|5|6|8|-1
5:6|0
6:5|0|1
7:5|3|4


1
|
3---------2
|		      |
4---5     9
|	  |	    |
8	  9--6  5----4----7
	  |  |  |	   |    |
	  7  8  6    8    6
	  	    |	        |
          8         8



small map 2


0 //
1 //
2
3
4
5
6
7
8



// I  STEPS ROOMS
// 0: 1 2 3
// 1: 4 5 6
// 2: 7 8 9
// ants: 3
// 			I  LEN  STEPS   PATHS
// options  0: -2   6       0
// 			1: -3   5       0 1
// 			2: -4   4       0 1 2
// 			3: -2   6       1
// 			4: -3   5       1 2
// 			5: -2   6       2
// 			// ... as many as there are possible combinations
// 			// find situation with the lowest steps!
// steps = 9       
// 			1     2
// 			a     3
// 			a	  4
// 			a	  5
// 			a	  6
// 			a	  7
// 			a	  8
// 			a     a
// 			a     a

/*

	SUB_MAP
	final_paths:
	i       len         rooms
	0                   1 3 4 8
	1                   1 2 4 8
	2                   1 2 5 6 8
	3                   1 2 7 6 8
	4                   1 3 5 6 8

    Options:
	i       len     steps       paths
	0       -3      x           0     | while
	1       -4      x           0 2
	2       -3      x           1     | while               
	3       -4      x           1 4
	4       -3      x           2     
	5       -3      x           3
	6       -3      x           4

*/