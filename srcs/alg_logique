s-r1  // 0
s-r2  // 1
r2-r3 // 2
r1-r3 // 3
r1-r4 // 4
r3-r5 // 5
r4-r3 // 6
r5-e // 7
e-r4 // 8

inteded:

s
|
r1 --- r2
|
r3

	s-r1-r4-end
	s-r1-r3-r4-end
	s-r2-r3-r4-end
  s-r2-r3-r5-end

	* r1-r4
	//r1-r3-r4
  //r2-r3-r4
	* r2-r3-r5


                    ---- s(0) ----
                  /                \
                r1(1) ------------ r2(2)
                  |                  |
        r4(9)--------r3(8)          r3(3)
          |            |             |
          e(10)        r5(11)        r5(4) ---- r4(5)
                        |             |           |
                        e(12)        e(7)         e(6)

	S	   
   |  \    
   r2  r1		
    \    | \
      - r3 - r4	  
	   	|		\   |
		r5 ---  end 

s-r2-r3-r4-e
s-r2-r3-r5-e
s-r2-r3-r5-r4-e
s-r2-r3-r5-r4-e
s-r1-r3-r4-e
s-r1-r3-r5-e
s-r1-r4-e
s-r1-r4-r3-r5-e







0-4 
0-6
1-3 
4-3 
5-2
3-5 
4-2 
2-1 
7-6 
7-2 
7-4 //
6-5

              ____________
            /              \
      ____[5]------[3]--[1] |
     /              |    /  |
   [6]------[0]----[4]  /   |
    \    _________/ |  /    |
     \ /           [2]/____/
     [7]___________/



1
|
3---------2
|		  |
4---5     9
|	|	  |
8	9--6  5----4----7
	|  |  |	   |    |
	7  8  6    8    6
	  	  |	        |
          8         8


1
|
2----sibling
|       |
|       6
3
|
4
|
5
|
6



1
|
3(1)---------------2
|                  |
4(2)---5           5(3)-----4-----7-----x----c-----v----b--f-----g----r
|      |             |      |     |
8(9)  6(10)         6(4)    8(5)  6(6)
        |             |           |
        8(11)        8(8)         8(7)

EXAMPLE: We are at  now:
0   [8, 4, 0]
1   [8, 6, 0]
2   [1, 3, -2]
3   [4, 3, -1]
4   [5, 2, -2]
5   [3, 5, -1]
6   [4, 2, -2]
7   [2, 1, -2]
8   [7, 6, 0]
9   [7, 2, -2]
10  [7, 4, 0]
11  [6, 5, -1]

tunnel_directory
0   [8, 4, 0]
1   [8, 6, 0]
2   [1, 3, 0]
3   [4, 3, 0]
4   [5, 2, 0]
5   [3, 5, 0]
6   [4, 2, 0]
7   [2, 1, 0]
8   [7, 6, 0]
9   [7, 2, 0]
10  [7, 4, 0]
11  [6, 5, 0]

EXAMPLE: We are at 7 now:
0   [8, 4, 1]
1   [8, 6, 0]
2   [1, 3, -2]
3   [4, 3, 3]
4   [5, 2, -1]
5   [3, 5, 3]
6   [4, 2, -1]
7   [2, 1, -2]
8   [7, 6, 0]
9   [7, 2, -1]
10  [7, 4, 1]
11  [6, 5, 2]

pos = scanning position (sibling)
neg = parent
0 = open


1
|
3--2
|  |
|  5--4--7
|  |  |  |
|  |  |  6
|  |  |  |
|  |  |  8
|  |  8
|  6
|  |
|  8
|
4--5
       



// Need to have a condition where if only one ant, send it thru the best path right away.
// If more than one ant, prefer multi-paths even if one or two step longer.


        
         [s] 
      /   |
  [r1]   [r2]---[r3]
    |     |      |
  [r4]---[r5]   [r6]
          |   /
         [e]

              Path 1             Path 2             Path 3       
            s-r2-r5-e         s-r1-r4-r5-e      s-r2-r3-r6-e
Length          2                   3                 3
ANTS           Single                     Both
1               3                          
2               4                          4
3               5                          5
4               6                          5

if (ants < 4)
    use path 1

Int path 1 s-r2-r5-e

int path 2
int path 3


ANTS   STEPS MIDDLE | ALL

1              1
2              2        2
3              3        2
4              


s r3  r2 r4 r1 e
1  2  3  4   5 9

int arr = 0[ 1, 2, 8, 9]
          1[ 1, 6, 2, 9]
          2[ 1, 5, 4, 2, 9]

          3[ 1, 5, 9]
          4[ 1, 4, 2, 9]


0:-4|1|3|4|8|-1
1:-5|1|2|5|6|8|-1
2:-4|1|2|4|8|-1
3:-5|1|2|7|6|8|-1
4:-5|1|3|5|6|8|-1
5:6|0
6:5|0|1
7:5|3|4


1
|
3---------2
|		      |
4---5     9
|	  |	    |
8	  9--6  5----4----7
	  |  |  |	   |    |
	  7  8  6    8    6
	  	    |	        |
          8         8



small map 2


0 //
1 //
2
3
4
5
6
7
8



// I  STEPS ROOMS
// 0: 1 2 3
// 1: 4 5 6
// 2: 7 8 9
// ants: 3
// 			I  LEN  STEPS   PATHS
// options  0: -2   6       0
// 			1: -3   5       0 1
// 			2: -4   4       0 1 2
// 			3: -2   6       1
// 			4: -3   5       1 2
// 			5: -2   6       2
// 			// ... as many as there are possible combinations
// 			// find situation with the lowest steps!
// steps = 9       
// 			1     2
// 			a     3
// 			a	  4
// 			a	  5
// 			a	  6
// 			a	  7
// 			a	  8
// 			a     a
// 			a     a

/*

	SUB_MAP
	final_paths:
	i       len         rooms
	0                   1 3 4 8
	1                   1 2 4 8
	2                   1 2 5 6 8
	3                   1 2 7 6 8
	4                   1 3 5 6 8


	2       -3      x           1     | while               
	3       -4      x           1 4
	4       -3      x           2     
	5       -3      x           3
	6       -3      x           4

*/


/*
	If we have 0 and 2 combined, how do we get the steps.
	
	final_paths[0][0] = -5
	final_paths[2][0] = -6

	Convert to positive and -3.

	2
	3
	
	Ants = 20

	Count inserted ants and the len together, and see how long first path gets.
	Ants: 
		
	    11 10
__________________
        ,,
	    2       3
__________________
        ,,      ,
        2       3

Total:  4       4
Steps:  4

*/
one
two
three
one-two
two-three


int **tunnel_directory
[1, 2]
[2, 3]

get_tunnel()


while tunnel_dir is empty
  while we scan thru directory
    if directory[i] == roomname
      store i into that place in tunnel_directory


i{roomnum}  name


room_dir

i	room name in str
0	start
1	r3
2	r2

tunnels_dir
i	roomnum1	roomnum2
0 = {0		, 	1}       <------- start-r3
1
2